--my_fir

library IEEE;
use IEEE.STD_LOGIC_1164.ALL;
use IEEE.NUMERIC_STD.ALL;
use work.aux_package.ALL;

-----------------------------------------
-- Entity Declaration for FIR Filter
-----------------------------------------
entity FIR_Filter is
    Port (
        -- Clock and Reset
        FIRCLK   : in  STD_LOGIC;          -- FIR core clock
        FIFOCLK  : in  STD_LOGIC;          -- FIFO clock
        FIRRST   : in  STD_LOGIC;          -- FIR core reset
        FIFORST  : in  STD_LOGIC;          -- FIFO reset
        
        -- Control signals
        FIRENA   : in  STD_LOGIC;          -- FIR core enable
        FIFOWEN  : in  STD_LOGIC;          -- FIFO write enable
        FIFOREN  : in  STD_LOGIC;          -- FIFO read enable
        
        -- Status signals
        FIFOFULL : out STD_LOGIC;          -- FIFO full status
        FIFOEMPTY: out STD_LOGIC;          -- FIFO empty status
        FIRIFG   : out STD_LOGIC;          -- FIR interrupt flag
        FIRIFG_OUTREADY : out STD_LOGIC;   -- NEW: asserts when FIROUT is valid
        
        -- Data interface
        FIRIN    : in  STD_LOGIC_VECTOR(31 downto 0);   -- FIR input data
        FIROUT   : out STD_LOGIC_VECTOR(31 downto 0);   -- FIR output data
        
        -- Coefficient interface
        COEF0,COEF1,COEF2,COEF3,
        COEF4,COEF5,COEF6,COEF7 : in STD_LOGIC_VECTOR(7 downto 0);
        
        -- Memory interface
        Addr     : in  STD_LOGIC_VECTOR(11 downto 0);
        FIRRead  : in  STD_LOGIC;
        FIRWrite : in  STD_LOGIC;
        
        -- Interrupt control
        FIRIFG_CLR : in STD_LOGIC       -- Clear FIR interrupt flag
    );
end FIR_Filter;

----------------------------------------
-- Architecture Definition
----------------------------------------
architecture Behavioral of FIR_Filter is
    -- Constants
    constant M : integer := 8;  -- Number of filter taps
    constant W : integer := 24; -- Data width
    constant k : integer := 8;  -- FIFO depth parameter
    
    -- FIFO signals
    type fifo_array is array (0 to 2**k-1) of STD_LOGIC_VECTOR(W-1 downto 0);
    signal fifo_memory    : fifo_array := (others => (others => '0'));
    signal fifo_wr_ptr    : integer range 0 to 2**k-1 := 0;
    signal fifo_rd_ptr    : integer range 0 to 2**k-1 := 0;
    signal fifo_count_wr  : integer range 0 to 2**k := 0;
    signal fifo_count_rd  : integer range 0 to 2**k := 0;
    signal fifo_count     : integer range 0 to 2**k := 0;
    
    -- FIR filter signals
    type delay_line is array (0 to M-1) of STD_LOGIC_VECTOR(W-1 downto 0);
    type coeff_array is array (0 to M-1) of STD_LOGIC_VECTOR(31 downto 0);
    signal x_delay        : delay_line := (others => (others => '0'));
    signal coefficients   : coeff_array := (others => (others => '0'));
    
    -- Processing signals
    signal x_input        : STD_LOGIC_VECTOR(W-1 downto 0) := (others => '0');
    signal y_output       : STD_LOGIC_VECTOR(31 downto 0)  := (others => '0');
    signal processing_active : STD_LOGIC := '0';
    
    -- Clock domain crossing synchronizer
    signal fifo_ren_sync1, fifo_ren_sync2 : STD_LOGIC := '0';
    
    -- Internal status signals
    signal fifo_empty_internal : STD_LOGIC := '1';
    signal fifo_full_internal  : STD_LOGIC := '0';
    signal output_valid        : STD_LOGIC := '0';
    
begin
    -----------------------------------------------------------------
    -- FIFO status flags
    -----------------------------------------------------------------
    FIFOEMPTY <= fifo_empty_internal;
    FIFOFULL  <= fifo_full_internal;
    
    -----------------------------------------------------------------
    -- Clock domain crossing synchronizer for FIFOREN
    -----------------------------------------------------------------
    process(FIFOCLK, FIFORST)
    begin
        if FIFORST = '1' then
            fifo_ren_sync1 <= '0';
            fifo_ren_sync2 <= '0';
        elsif rising_edge(FIFOCLK) then
            fifo_ren_sync1 <= FIFOREN;
            fifo_ren_sync2 <= fifo_ren_sync1;
        end if;
    end process;
    
    -----------------------------------------------------------------
    -- FIFO write process
    -----------------------------------------------------------------
    process(FIFOCLK, FIFORST)
    begin
        if FIFORST = '1' then
            fifo_wr_ptr   <= 0;
            fifo_count_wr <= 0;
        elsif rising_edge(FIFOCLK) then
            if FIFOWEN = '1' and fifo_count < 2**k then
                fifo_memory(fifo_wr_ptr) <= FIRIN(W-1 downto 0);
                fifo_wr_ptr   <= (fifo_wr_ptr + 1) mod 2**k;
                fifo_count_wr <= fifo_count_wr + 1;
            end if;
        end if;
    end process;
    
    -----------------------------------------------------------------
    -- FIFO read process
    -----------------------------------------------------------------
    process(FIRCLK, FIRRST)
    begin
        if FIRRST = '1' then
            fifo_rd_ptr   <= 0;
            x_input       <= (others => '0');
            fifo_count_rd <= 0;
        elsif rising_edge(FIRCLK) then
            if fifo_ren_sync2 = '1' and fifo_count > 0 then
                x_input       <= fifo_memory(fifo_rd_ptr);
                fifo_rd_ptr   <= (fifo_rd_ptr + 1) mod 2**k;
                fifo_count_rd <= fifo_count_rd + 1;
            end if;
        end if;
    end process;
    
    -----------------------------------------------------------------
    -- FIFO count (synchronous update)
    -----------------------------------------------------------------
    process(FIFOCLK, FIFORST)
    begin
        if FIFORST = '1' then
            fifo_count <= 0;
            fifo_empty_internal <= '1';
            fifo_full_internal  <= '0';
        elsif rising_edge(FIFOCLK) then
            fifo_count <= fifo_count_wr - fifo_count_rd;
            fifo_empty_internal <= '1' when fifo_count = 0 else '0';
            fifo_full_internal  <= '1' when fifo_count = 2**k else '0';
        end if;
    end process;
    
    -----------------------------------------------------------------
    -- Load coefficients
    -----------------------------------------------------------------
    coefficients(0) <= (23 downto 0 => '0') & COEF0;
    coefficients(1) <= (23 downto 0 => '0') & COEF1;
    coefficients(2) <= (23 downto 0 => '0') & COEF2;
    coefficients(3) <= (23 downto 0 => '0') & COEF3;
    coefficients(4) <= (23 downto 0 => '0') & COEF4;
    coefficients(5) <= (23 downto 0 => '0') & COEF5;
    coefficients(6) <= (23 downto 0 => '0') & COEF6;
    coefficients(7) <= (23 downto 0 => '0') & COEF7;
    
    -----------------------------------------------------------------
    -- FIR filter processing
    -----------------------------------------------------------------
    process(FIRCLK, FIRRST)
        variable temp_sum : signed(55 downto 0);
        variable temp_mul : signed(55 downto 0);
    begin
        if FIRRST = '1' then
            x_delay <= (others => (others => '0'));
            y_output <= (others => '0');
            processing_active <= '0';
        elsif rising_edge(FIRCLK) then
            if FIRENA = '1' and fifo_empty_internal = '0' then
                -- shift delay line
                for i in M-1 downto 1 loop
                    x_delay(i) <= x_delay(i-1);
                end loop;
                x_delay(0) <= x_input;
                
                -- FIR computation
                temp_sum := (others => '0');
                for i in 0 to M-1 loop
                    temp_mul := signed(x_delay(i)) * signed(coefficients(i));
                    temp_sum := temp_sum + temp_mul;
                end loop;
                -- take upper 32 bits
                y_output <= std_logic_vector(temp_sum(55 downto 24));
                processing_active <= '1';
            else
                processing_active <= '0';
            end if;
        end if;
    end process;
    
    -----------------------------------------------------------------
    -- Output valid flag
    -----------------------------------------------------------------
    process(FIRCLK, FIRRST)
    begin
        if FIRRST = '1' then
            output_valid <= '0';
        elsif rising_edge(FIRCLK) then
            if FIRENA = '1' and fifo_empty_internal = '0' then
                output_valid <= '1';
            else
                output_valid <= '0';
            end if;
        end if;
    end process;
    
    -----------------------------------------------------------------
    -- Outputs
    -----------------------------------------------------------------
    FIROUT <= "00000000" & y_output(23 downto 0);
    
    FIRIFG <= '0' when FIRIFG_CLR = '1' else output_valid;
    FIRIFG_OUTREADY <= output_valid;
    
end Behavioral;
